
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

      <title>Functional Programming Principles in Scala - Lists</title>
    <meta name="description" content="">
    <meta name="apple-mobile-web-app-title" content="Functional Programming Principles in Scala - Lists">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <link rel="shortcut icon" href="../assets/img/favicon.ico?v=736a175111">
<link rel="apple-touch-icon" href="../assets/img/appletouchicon.png?v=736a175111">

    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css">

    <style type="text/css">
    a, a:visited {color: #3498db;}
    .pagination a {color: #3498db;}
    .gist .gist-file .gist-meta a:visited {color: #3498db !important;}

    a:focus, a:hover {color: #2079b4;}
    h1.post-title a:focus, h1.post-title a:hover, h1.blog-title a:focus, h1.blog-title a:hover {color: #2079b4;}
    .older-posts:hover, .newer-posts:hover {color: #2079b4;}
</style>
    

    <link rel="stylesheet" href="../assets/css/screen.css?v=736a175111">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
    <link rel="stylesheet" href="../assets/css/github.css?v=736a175111">

    

    <link rel="canonical" href="http://tocology.github.io/functional-programming-principles-in-scala-lists/">
    <meta name="referrer" content="origin">
    
    <meta property="og:site_name" content="tocology">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Functional Programming Principles in Scala - Lists">
    <meta property="og:description" content="5.1 More Functions on Lists 앞서 보았던 것과 추가로 List의 Method 몇가지를 더 보자. Sublists and element access xs.length - The number of elements of xs. xs.last - The list's last element, exception if xs is empty....">
    <meta property="og:url" content="http://tocology.github.io/functional-programming-principles-in-scala-lists/">
    <meta property="article:published_time" content="2016-06-29T13:25:50.824Z">
    <meta property="article:modified_time" content="2016-06-29T13:25:50.819Z">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Functional Programming Principles in Scala - Lists">
    <meta name="twitter:description" content="5.1 More Functions on Lists 앞서 보았던 것과 추가로 List의 Method 몇가지를 더 보자. Sublists and element access xs.length - The number of elements of xs. xs.last - The list's last element, exception if xs is empty....">
    <meta name="twitter:url" content="http://tocology.github.io/functional-programming-principles-in-scala-lists/">
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "tocology",
    "author": {
        "@type": "Person",
        "name": "tocology",
        "image": "http://tocology.github.io/content/images/2015/10/Profile.jpg",
        "url": "http://tocology.github.io/author/tocology",
        "sameAs": "https://kr.linkedin.com/in/junhohwang",
        "description": "Always develop myself.."
    },
    "headline": "Functional Programming Principles in Scala - Lists",
    "url": "http://tocology.github.io/functional-programming-principles-in-scala-lists/",
    "datePublished": "2016-06-29T13:25:50.824Z",
    "dateModified": "2016-06-29T13:25:50.819Z",
    "description": "5.1 More Functions on Lists 앞서 보았던 것과 추가로 List의 Method 몇가지를 더 보자. Sublists and element access xs.length - The number of elements of xs. xs.last - The list&#x27;s last element, exception if xs is empty...."
}
    </script>

    <meta name="generator" content="Ghost 0.7">
    <link rel="alternate" type="application/rss+xml" title="tocology" href="http://tocology.github.io/rss/">
    <script>
var profile_title = 'Tocology';
var profile_resume ='Software Engineer';
var disqus_shortname = 'tocology';
</script>
</head>
<body class="post-template">

    <header id="site-head">
        <h1 class="blog-title"><a href="http://tocology.github.io">tocology</a></h1>
        <h1 class="blog-subtitle">Data Processing and Visualization for Big Data.</h1>
    </header>

    <nav class="menu" role="nav">
    <ul>
                <li class="nav-home"><a href="http://tocology.github.io/">Home</a></li>
                <li class="nav-article"><a href="http://tocology.github.io/article/">Article</a></li>
    </ul>
</nav>


    
<main class="content" role="main">

    <article class="post">


        <header>
        <h1 class="post-title">Functional Programming Principles in Scala - Lists</h1>
        <div class="post-meta"><time datetime="2016-06-29">29 June 2016</time></div>
        </header>

        <section class="post-content">
            <h1 id="51morefunctionsonlists">5.1 More Functions on Lists</h1>

<p>앞서 보았던 것과 추가로 List의 Method 몇가지를 더 보자.</p>

<p><strong>Sublists and element access</strong></p>

<ul>
<li><code>xs.length</code> - The number of elements of <code>xs</code>.</li>
<li><code>xs.last</code> - The list's last element, exception if <code>xs</code> is empty.</li>
<li><code>xs.init</code> - A List consisting of all elements of <code>xs</code> except the last one, exception if <code>xs</code> is empty.</li>
<li><code>xs take n</code> - A List consisting of the first n elements of <code>xs</code>, or <code>xs</code> itselft if it is shorter than n.</li>
<li><code>xs drop n</code> - The rest of the collection after taking n elements.</li>
<li><code>xs(n)</code> - (or, written out, <code>xs apply n</code>). The element of <code>xs</code> at index n.</li>
</ul>

<p><strong>Creating new lists</strong></p>

<ul>
<li><code>xs ++ ys</code> - The list consisting of all elements of <code>xs</code> followed by all elements of <code>ys</code>.</li>
<li><code>xs.reverse</code> - The list containing the elements of <code>xs</code> in reversed order.</li>
<li><code>xs updated (n, x)</code> - The list containing the same elements as <code>xs</code>, except at index <code>n</code> where it contains <code>x</code>.</li>
</ul>

<p><strong>Finding elements</strong></p>

<ul>
<li><code>xs indexOf x</code> - The index of the first element in <code>xs</code> equal to <code>x</code>, or <code>-1</code> if <code>x</code> does not appear in <code>xs</code>.</li>
<li><code>xs contains x</code> - same as <code>xs indexOf x &gt;= 0</code></li>
</ul>

<h3 id="implementationoflast">Implementation of <code>last</code></h3>

<p><code>head</code>의 complexity는 constant time이다. 그럼 <code>last</code>의 경우는 어떨까? 일단 구현을 보자.</p>

<pre><code class="language-scala">def last[T](xs: List[T]): T = xs match {  
    case List() =&gt; throw new Error("last of empty list")
    case List(x) =&gt; x
    case y :: ys =&gt; last(ys)
}
</code></pre>

<p>따라서 <code>xs</code>의 길이만큼 시간이 걸린다는 것을 알 수 있다.</p>

<p>그럼 이번에는 <code>init</code>을 구현해보자.</p>

<pre><code class="language-scala">def init[T](xs: List[T]): List[T] = xs match {  
    case List() =&gt; throw new Error("init of empty list")
    case List(x) =&gt; List()
    case y :: ys =&gt; y :: init(ys)
}
</code></pre>

<h3 id="implementationofconcatenation">Implementation of Concatenation</h3>

<p>이번에는 concatenation을 어떻게 구현할지 보자.</p>

<p>기본적으로 두개의 list를 붙일 경우 아래와 같이 operation을 이용하여 구현할 수 있다.</p>

<pre><code class="language-scala">xs ::: ys // ys.:::(xs)  
</code></pre>

<p>동일하게 동작하는 <code>concat</code> 함수를 구현하면 아래와 같다.</p>

<pre><code class="language-scala">def concat[T](xs: List[T], ys: List[T]) = xs match {  
    case List() =&gt; ys 
    case z :: zs =&gt; z :: concat(zs, ys)
}
</code></pre>

<p>complexity는 | xs | 이다. ( | | 는 길이를 의미한다.)</p>

<h3 id="implementationofreverse">Implementation of <code>reverse</code></h3>

<p>이번에는 <code>reverse</code>를 구현해보자</p>

<pre><code class="language-scala">def reverse[T](xs: List[T]): List[T] = xs match {  
    case List() =&gt; xs
    case y :: ys =&gt; reverse(ys) ++ List(y)
}
</code></pre>

<p>complexity는 | xs | * | xs | 로 다소 오래걸리게 된다. (xs 길이만큼 재귀가 돌고, 각 재귀마다 <code>++</code> operation에 대해 계산하게 되기 때문에) 나중에 더 나은 방법을 보도록 하자.</p>

<p>마지막으로 <code>removeAt</code> 함수를 구현해보자. <code>removeAt</code>은 아래와 같이 동작해야한다.</p>

<pre><code class="language-scala">removeAt(1, List('a', 'b', 'c', 'd')) // List(a, c, d)  
</code></pre>

<pre><code class="language-scala">def removeAt[T](n: Int, xs: List[T]): T = (xs take n) ::: (xs drop n + 1)  
</code></pre>

<h1 id="52pairsandtuples">5.2 Pairs and Tuples</h1>

<h3 id="sortinglistsfaster">Sorting Lists Faster</h3>

<p>이전에 보았던 <em>insertion sort</em>보다 향상된 <em>merge sort</em>를 보도록하자. merge sort에 대한 아이디어는 만약 list가 0 또는 1개의 element를 가질때 이미 정렬되어 있다는 것에서 기반한다. 그렇지 않은 경우</p>

<ul>
<li>list를 두개의 sub-list로 나누는데 원래 list의 element를 반씩 가지고 있게 한다.</li>
<li>두개의 sub-list를 정렬한다.</li>
<li>그 두개의 sub-list를 하나의 list로 합친다(Merge).</li>
</ul>

<p>이것을 Scala로 구현하면 아래와 같다.</p>

<pre><code class="language- scala">def msort(xs: List[Int]): List[Int] = {  
    val n = xs.length / 2
    if (n == 0) xs
    else {
        def merge(xs: List[Int], ys: List[Int]) = 
        val (fst, snd) = xs splitAt n
        merge(msort(fst), msort(snd))
    }
}
</code></pre>

<p>여기서 <code>merge</code>를 구현하면 아래와 같다.</p>

<pre><code class="language-scala">def meger(xs: List[Int], ys: List[Int]) =  
    xs match {
        case Nil =&gt; ys
        case x :: xs1 =&gt; ys match {
                case Nil =&gt; xs
                case y :: ys1 =&gt;
                    if (x &lt; y) x :: merge(xs1, ys)
                    else y :: merge(xs, ys1)
        }
    }
}
</code></pre>

<h3 id="thesplitatfunction">The SplitAt Function</h3>

<p>여기서 <code>splitAt</code> 함수를 보면 주어진 n을 기점으로 두개의 sublist를 돌려준다. 여기서 list들은 한 <em>pair</em>에 담아 돌려받게 된다. </p>

<p>pair는 아래와 같은 예처럼 사용이 가능하다.</p>

<pre><code class="language-scala">val pair = ("answer", 42)  &gt; pair : (String, Int) = (answer, 42)  
val (label, value) = pair  &gt; label : String = answer  
                           | value : Int = 42
</code></pre>

<p>이 동작은 두개 이상의 element에 대한 <em>tuple</em>과 동일하다.</p>

<p>이전에 보았던 <code>Function n</code>과 동일하게 <code>tuple</code>도 각각에 대한 정의가 되어있다.</p>

<pre><code class="language-scala">case class Tuple2[T1, T2](_1: +T1, _2: +T2) {  
    override def toString = "(" + _1 + "," + _2 + ")"
}
</code></pre>

<p>따라서, 앞서 봤던 pattern matching 형태가 더 선호되지만 아래와 같이 사용할 수도 있다.</p>

<pre><code class="language-scala">val label = pair._1  
val value = pair._2  
</code></pre>

<p>이러한 pair을 이용하여 앞서 구현했던 <code>merge</code> 함수를 아래와 같이 수정할 수 있다.</p>

<pre><code class="language-scala">def merge(xs: List[Int], ys: List[Int]): List[Int] = (xs, ys) match {  
    case (Nil, ys) =&gt; ys
    case (xs, Nil) =&gt; xs
    case (x :: xs1, y :: ys1) =&gt; 
        if (x &lt; y) x :: match(xs1, ys)
        else y :: match(xs, ys1)
}
</code></pre>

<h1 id="53implicitparameters">5.3 Implicit Parameters</h1>

<p>여기서 Merge sort를 일반화해보자. 지금 현재는 Int에 대해서만 동작한다. 그럼 <code>Double</code> 및 <code>Boolean</code> 등 여러가지 자료구조를 포함하여 아래와 같이 구현이 가능할까?</p>

<pre><code class="language-scala">def msort[T](xs: List[T]): List[T] = ...  
</code></pre>

<p>지금 현재 구현된 내용으로는 불가하다. 이유는 비교 연산자인 <code>&lt;</code>가 모든 type에 대해 동작 가능한 것이 아니기 때문이다. 그럼 어떻게 해결할까? 이를 위해 비교 연산 함수를 parameter로 받으면 된다.</p>

<h3 id="parameterizationofsort">Parameterization of Sort</h3>

<p>따라서 추가적인 parameter를 받도록 설계해보자.</p>

<pre><code class="language-scala">def msort[T](xs: List[T])(lt: (T, T) =&gt; Boolean) = {  
    ...
    merge(msort(fst)(lt), msort(snd)(lt))
}

def merge(xs: List[T], ys: List[T]) = (xs, ys) match {  
    ...
    case (x :: xs1, y :: ys1) =&gt;
        if (lt(x, y)) ...
        else ...
}
</code></pre>

<p>따라서, String에 대해서 처리할 경우 아래와 같이 적용할 수 있다.</p>

<pre><code class="language-scala">val fruits = List("apple", "pineapple", "orange", "banana")

msort(fruits)((x: String, y: String) =&gt; x.compareTo(y) &lt; 0)  
</code></pre>

<h3 id="parametrizationwithordered">Parametrization with Ordered</h3>

<p>위와 같이 비교연산자를 구현하여 추가할 수도 있지만, scala에서 standard library로 order를 제공하는 api를 사용할 수도 있다.</p>

<pre><code class="language-scala">scala.math.Ordering[T]  
</code></pre>

<p>따라서 이걸 이용하여 구현하면 아래와 같이 할 수 있는데,</p>

<pre><code class="language-scala">def msort[T](xs: List[T])(ord: Ordering) =

    def meger(xs: List[T], ys: List[T]) =
        ... if (ord.lt(x, y)) ...

... merge(msort(fst)(ord), msort(snd)(ord)) ...
</code></pre>

<p>이렇듯 다른 함수를 추가 구현하여 넘겨주지 않아도 된다. 따라서 <code>msort</code>를 호출 할때는 아래와 같이 호출하면 된다.</p>

<pre><code class="language-scala">import math.Ordering

...
msort(nums)(Ordering.Int)  
msort(fruits)(Ordering.String)  
</code></pre>

<h3 id="implicitparameter">Implicit Parameter</h3>

<p>하지만, 일일이 <code>ord</code> 값을 넘겨주는 일도 귀찮을 수 있다. 이럴 경우 <em>Implicit Parameter</em>를 통해 해결할 수 있다.</p>

<pre><code class="language-scala">def msort[T](xs: List[T])(implicit ord: Ordering) =

    def merge(xs: List[T], ys: List[T]) =
        ... if (ord.lt(x, y)) ...

... merge(msort(fst), msort(snd)) ...
</code></pre>

<p>또한, complier에 의해 자동으로 type이 넘어가게 되어 호출할 때도 아래처럼 할 수 있다.</p>

<pre><code class="language-scala">msort(nums)  
msort(fruits)  
</code></pre>

<h3 id="rulesforimplicitparameters">Rules for Implicit Parameters</h3>

<p>만약 함수가 type T 의 implicit parameter를 받는 다면 아래와 같은 rule에 따라 implicit definition을 찾게 된다.</p>

<ul>
<li><code>implicit</code>로 마크되어 있는 경우</li>
<li><code>T</code>와 type이 호환(compatible)되는 경우</li>
<li>함수하는 시점이 보여야하거나 <code>T</code>와 관련된 companion object안에 정의가 되어 있는 경우</li>
</ul>

<h1 id="54higherorderlistfunctions">5.4 Higher-Order List Functions</h1>

<p>이전까지 본 함수들을 보면 list에 대해 동일한 구조를 가진 것을 볼 수 있다. 예를 들어,</p>

<ul>
<li>각각 element에 대해 동일한 방법을 적용하여 변경하거나,</li>
<li>특정한 기준을 만족하는 list의 element를 돌려주거나,</li>
<li>operator를 이용하여 list를 합치거나,</li>
</ul>

<p>이러한 pattern을 구현한 일반 함수를 <strong>higher-order function</strong>을 사용하여 해결할 수 있
다.</p>

<h3 id="applyingafunctiontoelementsofalist">Applying a Function to Elements of a List</h3>

<p>흔한 operation은 list의 각각 element를 변경하여 그 결과를 돌려주는 것이다. 예를 들어, factor를 모든 element에 적용하는 함수를 구현하고자 할때,</p>

<pre><code class="language-scala">def scaleList(xs: List[Double], factor: Double): List[Double] = xs match {  
    case Nil     =&gt; xs
    case y :: ys =&gt; y * factor :: scaleList(ys, factor)
}
</code></pre>

<p>위와 같이 구현할 수 있다.</p>

<h3 id="map">Map</h3>

<p>List class에 <code>map</code>이라는 method가 있는데 아래와 같이 정의를 보자.</p>

<pre><code class="language-scala">abstract class List[T] {  
    def map[U](f: T =&gt; U): List[U] = this match {
        case Nil     =&gt; this
        case x :: xs =&gt; f(x) :: xs.map(f)
    }
</code></pre>

<p>(실제로는 tail-recursive로 구현되기 때문에 훨씬 복잡하다.)</p>

<p>이러한 <code>map</code>을 <code>scaleList</code>에 적용하면 아래와 같이 된다.</p>

<pre><code class="language-scala">def scaleList(xs: List[Double], factor: Double) =  
    xs map (x =&gt; x * factor)
</code></pre>

<p>그럼 이번에는 다른 예로 <code>squareList</code> 함수를 구현해보자. 모든 element에 대해 제곱을 적용하면된다. 위와 같이 두가지 방법을 모두 사용해보자.</p>

<pre><code class="language-scala">def squareList(xs: List[Int]): List[Int] =  
  xs match {
    case Nil     =&gt; xs // Nil
    case y :: ys =&gt; y * y :: squareList(ys)
  }

def squareList(xs: List[Int]): List[Int] =  
  xs map (x =&gt; x * x)
</code></pre>

<h3 id="filter">Filter</h3>

<p>이번에는 비슷하지만 다른 operation을 보자. 주어진 조건(condition)을 통과하는 element만 돌려주는 함수이다.</p>

<pre><code class="language-scala">def posElems(xs: List[Int]): List[Int] = xs match {  
    case Nil     =&gt; xs
    case y :: ys =&gt; if (y &gt; 0) y :: posElems(ys) else posElems(ys)
</code></pre>

<p>구현을 보면 <code>(y &gt; 0)</code>(condition)을 통과하는 element에 대해서만 추가(<code>::</code>)되는 것을 볼 수 있다.</p>

<p>이와 동일하게 행동하는 <code>List</code>의 method로 <code>filter</code>가 있다.</p>

<pre><code class="language-scala">abstract class List[T] {  
    ...
    def filter(p: T =&gt; Boolean): List[T] = this match {
        case Nil     =&gt; this
        case x :: xs =&gt; if (p(x)) x :: xs.filter(p) else xs.filter(p)
    }
}
</code></pre>

<p>이를 이용하면 위의 구현이 아래와 같이 요약된다.</p>

<pre><code class="language-scala">def posElems(xs: List[Int]): List[Int] =  
    xs filter (x =&gt; x &gt; 0)
</code></pre>

<p>추가적으로 아래와 같은 함수들도 있다.</p>

<pre><code class="language-scala">nums filter (x =&gt; x &gt; 0)     // List[Int] = List(2, 5, 7, 1)  
nums filterNot (x =&gt; x &gt; 0)  // List[Int] = List(-4)  
nums partition (x =&gt; x &gt; 0)  // (List[Int], List[Int]) = (List(2, 5, 7, 1), List(-4))

nums takeWhile (x =&gt; x &gt; 0)  // List[Int] = List(2)  
nums dropWhile (x =&gt; x &gt; 0)  // List[Int] = List(-4, 5, 7, 1)  
nums span (x =&gt; x &gt; 0)       // (List[Int], List[Int]) = (List(2), List(-4, 5, 7, 1))  
</code></pre>

<h1 id="55reductionoflists">5.5 Reduction of Lists</h1>

<p>주어진 operation을 이용하여 list의 모든 element를 합치는(combine)하는 경우를 보자. 아래의 예를 보면,</p>

<pre><code class="language-scala">sum(List(x1, ..., xn))         = 0 + x1 + ... + xn  
product(List(x1, ..., xn))     = 1 * x1 * ... * xn  
</code></pre>

<p>이러한 경우 아래와 같이 recursive schema를 이용하여 구현할 수 있다.</p>

<pre><code class="language-scala">def sum(xs: List[Int]): Int = xs match {  
    case Nil     =&gt; 0
    case y :: ys =&gt; y + sum(ys)
}
</code></pre>

<h3 id="reduceleft">ReduceLeft</h3>

<p>이러한 pattern은 generic method은 <code>reduceLeft</code>를 이용하여 추상화할 수 있다.</p>

<p><code>reduceLeft</code>는 list 안에 근접한 element 간 operator 적용되도록 한다. </p>

<pre><code class="language-scala">List(x1, ..., xn) reduceLeft op = (...(x1 op x2) op ...) op xn  
</code></pre>

<p>따라서 아래와 같이 정리가 가능하다.</p>

<pre><code class="language-scala">def sum(xs: List[Int])     = (0 :: xs) reduceLeft ((x, y) =&gt; x + y)  
def product(xs: List[Int]) = (1 :: xs) reduceLeft ((x, y) =&gt; x * y)  
</code></pre>

<h3 id="ashorterwaytowritefunctions">A Shorter Way to Write Functions</h3>

<p><code>((x, y) =&gt; x * y))</code>대신에 아래와 같이 더 짧게 표현할 수 있다.</p>

<pre><code class="language-scala">(_ * _)
</code></pre>

<p>여기서 <code>_</code>는 새로운 parameter를 의미하고, 왼쪽에서 오른쪽으로 인식한다.</p>

<p>따라서, 이를 적용하여 아래와 같이 간단하게 표현할 수 있다.</p>

<pre><code class="language-scala">def sum(xs: List[Int])     = (0 :: xs) reduceLeft (_ + _)  
def product(xs: List[Int]) = (1 :: xs) reduceLeft (_ * _)  
</code></pre>

<h3 id="foldleft">FoldLeft</h3>

<p><code>reduceLeft</code> 보다 조금 더 일반화된 함수로 <code>foldLeft</code>가 있다.</p>

<p><code>foldLeft</code>는 <code>reduceLeft</code>와 동작방식이 유사하나 <em>accumulator</em> parameter를 추가로 받는 다는 점이 다르다. 따라서 아래와 같이 동작하게 되는데,</p>

<pre><code class="language-scala">(List(x1, ..., xn) foldLeft z)(op) = (...(z op x1) op ...) op xn
</code></pre>

<p>아래와 같이 이를 이용하여 정의를 변경할 수 있다.</p>

<pre><code class="language-scala">def sum(xs: List[Int])     = (xs foldLeft 0)(_ + _)  
def product(xs: List[Int]) = (xs foldLeft 1)(_ * _)  
</code></pre>

<p>이러한 두 method를 <code>List</code> class에 구현해보자.</p>

<pre><code class="language-scala">abstract class List[T] {  
    def reduceLeft(op: (T, T) =&gt; T): T = this match {
        case Nil     =&gt; throw new Error("Nil.reduceLeft")
        case x :: xs =&gt; (xs foldLeft x)(op)
    }
    def foldLeft[U](z: U)(op: (U, T) =&gt; U): U = this match {
        case Nil     =&gt; z
        case x :: xs =&gt; (xs foldleft op(z, x))(op)
    }
}
</code></pre>

<h3 id="foldrightandreduceright">FoldRight and ReduceRight</h3>

<p><code>foldLeft</code>와 <code>reduceLeft</code>를 트리에 풀면 왼쪽으로 기울어져있는 것을 볼 수 있다. 이거와 쌍을 이루는 함수로 <code>foldRight</code>와 <code>reduceRight</code>가 있는데, 이 둘은 트리에 풀면 오른쪽으로 치우쳐있다.</p>

<pre><code class="language-scala">List(x1, ..., x{n-1}, xn) reduceRight op = x1 op ( ... (x{n-1} op xn) ... )  
(List(x1, ..., xn) foldRight acc)(op)    = x1 op ( ... (xn op acc) ... )
</code></pre>

<p>이를 구현하면 아래와 같다.</p>

<pre><code class="language-scala">def reduceRight(op: (T, T) =&gt; T): T = this match {  
    case Nil =&gt; throw new Error("Nil.reduceRight")
    case x :: Nil =&gt; x
    case x :: xs =&gt; op(x, xs.reduceRight(op))
}
def foldRight[U](z: U)(op: (T, U) =&gt; U): U = this match {  
    case Nil =&gt; 2
    case x :: xs =&gt; op(x, (xs foldRight z)(op))
}
</code></pre>

<h3 id="differencebetweenfoldleftandfoldright">Difference between FoldLeft and FoldRight</h3>

<p>효율성에서 차이가 있을 수 있어도 결합법칙(associative)나 교환법칙(commutative)이 적용되는 operator에 대해 <code>foldLeft</code>나 <code>foldRight</code>는 동일한 결과를 돌려준다.</p>

<p>하지만, 때에 따라 둘 중 하나의 경우만 적절할 수 있다. 아래 예를 보자.</p>

<pre><code class="language-scala">def concat[T](xs: List[T], ys: List[T]): List[T] =  
    (xs foldRight ys) (_ :: _)
</code></pre>

<p>물론 이걸 이해하기 위해서는 그림으로 보는 것이 가장 도움이 되지만, 여건에 따라 상상하기로 하자. <code>ys</code>가 accumulator로 가장 오른쪽 하단에 붙고 나머지가 차례로 붙는다. 따라서 최종적으로 <code>xs</code>의 맨 마지막인 <code>xs{n}</code>과 <code>ys</code>가 결합하여 결과적으로 <code>xs</code>, <code>ys</code>순으로 List가 구성된다. 이 경우 만약 <code>foldRight</code>대신 <code>foldLeft</code>를 쓰면 어떻게 될까? 답은 type이 제대로 동작하지 않는다. 결과적으로 <code>ys</code> List에 <code>xs</code> element를 <code>::</code>를 통해 붙여나가려하기 때문이다.</p>

<h1 id="56reasoningaboutconcat">5.6 Reasoning About Concat</h1>

<h3 id="lawsofconcat">Laws of Concat</h3>

<p>연결(concatenation) operation 인 <code>++</code>를 보자. 만약 이 operation에 대해 결합법칙(associative)가 성립되고, 빈 list <code>Nil</code>에 대해서도 연결이 성립하는지 보고 싶다고 할 경우 어떻게 증명할 수 있을까?</p>

<pre><code class="language-scala">(xs ++ ys) ++ za = xs ++ (ys ++ zs)
       xs ++ Nil = xs
       Nil ++ xs = xs
</code></pre>

<p><em>structural induction</em> 을 통해 가능하다.</p>

<h3 id="remindernaturalinduction">Reminder: Natural Induction</h3>

<p>여기서 잠시 <em>natural induction</em>을 회상해보자. 모든 정수 <code>n &gt;= b</code>에 대해 <code>P(n)</code>이 성립하는 것을 증명하기 위해,</p>

<ul>
<li><code>P(b)</code> (<em>base case</em>) 에 대해 성립할 경우,</li>
<li>모든 정수 <code>n &gt;= b</code>에 대해 아래의 <em>induction step</em>을 보이면 된다.


<blockquote>
  <p>만약 <code>P(n)</code>이 된다면, <code>P(n+1)</code> 또한 가능하다.</p></blockquote></li>
  </ul>
  예를 들어,


<pre><code class="language-scala">def factorial(n: Int): Int =  
    if (n == 0) 1            // 1st clause
    else n * factorial(n-1)  // 2nd clause
</code></pre>



위와 같이 `factorial`이 있을 때,


<pre><code class="language-scala">factorial(n) &gt;= power(2, n)  
</code></pre>



을 증명하려 한다고 생각해보자.

여기서 **Base case**는 4 이다. 즉, 4에 대해서는 아래와 같이 명제가 성립한다.


<pre><code class="language-scala">factorial(4) = 24 &gt;= 16 = power(2, 4)  
</code></pre>





<h3 id="inductionstep">Induction Step</h3>

그럼 이번엔, n &gt;= 4에 대해서는 성립한다고 가정하고 **Induction step**으로 n+1에 대해 성립하는지 확인해보자.


<pre><code class="language-scala">factorial(n + 1)  
&gt;= (n + 1) * factorial(n)   // by 2nd clause in factorial
&gt;  2 * factorial(n)         // by calculating
&gt;= 2 * power(2, n)          // by induction hypothesis
=  power(2, n+1)            // by definition of power
</code></pre>

 



<h3 id="referentialtransparency">Referential Transparency</h3>

위와 같은 reduction step이 가능한 것이 중요한데, pure functional program은 side effects가 없기때문에 가능하다. 이러한 원리를 참조 투명성(*referential transparency*)라고 한다.



<h3 id="structuralinduction">Structural Induction</h3>

structural induction의 원리는 natural induction과 동일하다.

만약, list `xs`에 대해 `P(xs)`를 증명할 경우,

<ul>
<li><code>P(Nil)</code>에 대해서 증명을 한다. (<em>base case</em>)</li>
<li>list <code>xs</code>와 <code>x</code> element에 대해 <em>induction step</em>을 증명한다.
만약 <code>P(xs)</code>가 가능하면, <code>P(x :: xs)</code>에 대해서도 가능하다.</li>
</ul>

<p>예를 들어보면, 아래와 같이 결합법칙에 대해 증명해보자.</p>

<pre><code class="language-scala">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)
</code></pre>

<p><code>xs</code>에 대해서 structural induction을 사용해보자. 이전에 봤던 <code>concat</code>을 보면,</p>

<pre><code class="language-scala">def concat[T](xs: List[T], ys: List[T]) = xs match {  
    case List() =&gt; ys
    case x :: xs1 =&gt; x :: concat(xs1, ys)
}
</code></pre>

<p>또한 아래의 두가지는 <code>++</code> 에 대한 부분이다.</p>

<pre><code class="language-scala">       Nil ++ ys = ys               // 1st clause
(x :: xs1) ++ ys = x :: (xs1 ++ ys) // 2nd clause
</code></pre>

<h3 id="basecase">Base case</h3>

<p>여기서 base case로 <code>Nil</code>을 보자.</p>

<pre><code class="language-scala">// left-hand side
(Nil ++ ys) ++ zs
= ys ++ zs         // by 1st clause of ++

// right-hand side
Nil ++ (ys ++ zs)  
= ys ++ zs 
</code></pre>

<p>위와 같이 성립하는 것을 볼 수 있다.</p>

<h3 id="inductionsteplhs">Induction Step: LHS</h3>

<p>그럼 induction step중 left-hand side부터 보자.</p>

<pre><code class="language-scala">((x :: xs) ++ ys) ++ zs
= (x :: (xs ++ ys)) ++ zs     // by 2nd clause of ++
= x :: ((xs ++ ys) ++ zs)     // by 2nd clause of ++
= x :: (xs ++ (ys ++ zs))     // by induction hypothesis
</code></pre>

<h3 id="inductionsteprhs">Induction Step: RHS</h3>

<p>다음으로 right-hand side를 보자.</p>

<pre><code class="language-scala">(x :: xs) ++ (ys ++ zs)
= x :: (xs ++ (ys ++ zs))     // by 2nd clause of ++
</code></pre>

<p>따라서 위 두가지 경우를 조합하여 <code>P(x :: xs)</code>의 경우에 증명이 가능하다고 판단할 수 있다.</p>

<h1 id="reference">Reference</h1>

<ul>
<li><a href="https://www.coursera.org/learn/progfun1">Functional Programming Principles in Scala</a>, Coursera</li>
</ul>
        </section>

        <section class="post-tags">
            
        </section>

        <section class="share">
            <p class="backtotop"><a data-scroll href="index.html#site-head"><i class="fa fa-lg fa-fw fa-angle-double-up"></i></a><a data-scroll class="backtotoptext" href="index.html#site-head"> Back to top</a></p>
            <p class="info prompt">Share</p>
            <a href="http://twitter.com/share?text=Functional%20Programming%20Principles%20in%20Scala%20-%20Lists&amp;url=http://tocology.github.io/functional-programming-principles-in-scala-lists/" title="Share on Twitter" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fa fa-2x fa-fw fa-twitter-square"></i> <span class="hidden">Twitter</span>
            </a>
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://tocology.github.io/functional-programming-principles-in-scala-lists/" title="Share on Facebook" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                <i class="fa fa-2x fa-fw fa-facebook-square" style="margin-left: -8px"></i> <span class="hidden">Facebook</span>
            </a>
            <a href="https://plus.google.com/share?url=http://tocology.github.io/functional-programming-principles-in-scala-lists/" title="Share on Google+" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                <i class="fa fa-2x fa-fw fa-google-plus-square" style="margin-left: -8px"></i> <span class="hidden">Google+</span>
            </a>
        </section>

        <footer class="post-footer">
            <section class="author">
    <div class="authorimage" style="background: url(../content/images/2015/10/Profile.jpg)"></div>
    <h4>tocology</h4>
    <p class="bio">Always develop myself..</p>
    <p class="meta">
      <i class="fa fa-fw fa-globe"></i> <a href="https://kr.linkedin.com/in/junhohwang">https://kr.linkedin.com/in/junhohwang</a><br>
      <i class="fa fa-fw fa-map-marker"></i> Soeul, South Korea
    </p>
</section>
        </footer>


        <div id="disqus_thread">
    <script type="text/javascript">
        var disqus_shortname = 'tocology';
        var disqus_identifier = '20';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

    </article>

</main>


    <footer class="site-footer">
        <div class="inner">
            <section class="footer-social">
    <!-- <a href="http://twitter.com/username" target="_blank" title="Twitter"><i class="fa fa-2x fa-fw fa-twitter"></i> <span class="hidden">Twitter</span></a>&nbsp; -->
    <a href="https://www.facebook.com/tocology" target="_blank" title="Facebook"><i class="fa fa-2x fa-fw fa-facebook"></i> <span class="hidden">Facebook</span></a> 
    <a href="https://github.com/tocology" target="_blank" title="GitHub"><i class="fa fa-2x fa-fw fa-github"></i> <span class="hidden">GitHub</span></a> 
    <a href="http://tocology.github.io/rss/" target="_blank" title="RSS"><i class="fa fa-2x fa-fw fa-rss"></i> <span class="hidden">RSS</span></a>
</section>
            <section class="bloginfo">A blog by <a href="mailto:hwangjun7777@gmail.com">tocology</a></section>
            <section class="copyright">© 2016 <a href="http://tocology.github.io">tocology</a>. All rights reserved</section>
            <section><a href="https://github.com/epistrephein/Steam">Steam theme</a> for <a class="icon-ghost" href="http://ghost.org/"><span class="hidden">Ghost</span></a> by Tommaso Barbato</section>
        </div>
    </footer>

    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>

    <script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
    <script src="../assets/js/index.js?v=736a175111"></script>
    
    <script src="http://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/7.1.1/js/smooth-scroll.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

    <script>
        smoothScroll.init({
            speed: 800,
            easing: 'easeInOutCubic',
            updateURL: false,
            offset: 125,
        });
    </script>
    <script>hljs.initHighlightingOnLoad();</script>

</body>
